---
title: "Análisis de la evolución de la incidencia de la COVID-19 en España"
author: "Juan Matorras Díaz-Caneja"
date: "`r format(Sys.time(), '%d/%m/%Y')`"
output: pdf_document
---

```{r Setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE)
library(lubridate)
library(knitr)
library(tidyverse)
library(data.table)
Sys.setlocale("LC_TIME", "es_ES.UTF-8")
Meses <- c("Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", 
           "Nov", "Dic")
poblESP <- 47.33E+06
```

## Introducción

Este es un ejercicio básico de análisis de los datos de la incidencia de la COVID-19 en España a lo largo de 2020. Habiendo la cantidad de informes y herramientas para el análisis de los datos sobre la incidencia de la COVID-19 que ya existen, este documento no pretende aportar nada singularmente nuevo y su razón de ser no es otra que poner en práctica y profundizar por mi parte en el aprendizaje de las técnicas de análisis de datos y el lenguaje R que he iniciado en la segunda mitad de septiembre de 2020.

Por su propia esencia, éste es un documento vivo que además der ser puesto al día periódicamente con los nuevos datos disponibles, va sufriendo adiciones, modificaciones y corrección de erratas. La última versión disponible de este documento y de los datos empleados en su elaboración se pueden encontrar en el repositorio de GitHub:  <https://github.com/JuanMatorras/Covid-19>.

Los datos de partida son los publicados por el Gobierno de España en la web **datos.gob.es** a través del siguiente enlace: <https://datos.gob.es/es/catalogo/e05070101-evolucion-de-enfermedad-por-el-coronavirus-covid-19>.

El grueso del informe se centra sobre los totales en España agregando los datos disponibles por Comunidades Autónomas, aunque también se muestran información de la incidencia en las CCAA de Madrid, Cantabria, Asturias y Galicia. La razón de la selección de estas comunidades y no otras responde a consideraciones personales y no obedece a ningún criterio técnico.

## Proceso metodológico y software utilizado

El archivo de datos no ha sido sometido a ningún tipo de modificación o alteración previa y su manipulación en este análisis es el mínimo imprescindible para permitir el tratamiento de los datos y obtención de resultados.

```{r Lectura de Datos y Simplificación de tabla}
DatosCompletos <- read.csv(file.path("data", "datos_ccaas.csv"))
## Descartamos el método de detección (PCR, antígenos,...)
DatosCCAAs <- DatosCompletos[, 1:3]
## Adecuación formato fechas para su correcta lectura
DatosCCAAs$fecha <- as.Date(DatosCCAAs$fecha, format = "%Y-%m-%d")
## Agrupación de imformación de CCAA para datos a nivel nacional
Datos <- DatosCCAAs %>% group_by(fecha) %>% summarise(num_casos = sum(num_casos), 
                                                      .groups = 'drop')
```

La fecha y hora de descarga de los datos que han sido utilizados para las tablas y gráficos incluídos en este informe ha sido (aaaa-mm-dd hh:mm:ss): **`r file.mtime(file.path("data", "datos_ccaas.csv"))`**

El análisis se ha llevado a cabo utilizando el software libre para análisis estadístico **R**, versión `r getRversion()`. (1)

Se ha hecho uso también de los paquetes complementarios:

* **lubridate** para facilitar el manejo de fechas. (2)
* **knitr** para mejorar la apariencia de tablas. (3)
* **tydiverse** por los paquetes que incluye para ayudar en la extracción de la información y los gráficos mejorados de **ggplot2**. (4)
* **data.table** con el objeto de manipular las tablas más eficientemente. (5)

## Incidencia mensual y número total de casos detectados desde el inicio de 2020

La evolución de número de casos notificados por meses se refleja en el gráfico que se muestra a continuación:

```{r Incidencia Mensual}
CasosMensuales <- tapply(Datos$num_casos, month(Datos$fecha), sum)
TablaCasosMensuales <- data.frame(head(Meses, length(CasosMensuales)), 
        format(CasosMensuales, big.mark = ".", decimal.mark = ","))
colnames(TablaCasosMensuales) <- c("Mes", "Nº casos mensuales")
TotalCasosOrigen <- sum(Datos$num_casos)
PorcentajePoblacion <- paste(format(TotalCasosOrigen / poblESP *100, digits = 4, 
    decimal.mark = ","), "%")
dfCasosMensuales <- data.frame(Mes = head(Meses, length(CasosMensuales)), 
                               Casos =  CasosMensuales)
dfCasosMensuales$Mes <- factor(dfCasosMensuales$Mes, levels = dfCasosMensuales$Mes)
d <- ggplot(dfCasosMensuales, aes(Mes, Casos))
d + geom_col()
```

Correspondiente a los valores que se incluyen en la tabla siguiente:

`r kable(TablaCasosMensuales, align = "r")`

El número total de casos acumulados desde el 1 de enero de 2020 hasta la fecha indicada en el punto anterior según los datos oficiales disponibles en ese momento ascienden a un total de **`r format(TotalCasosOrigen, big.mark = ".", decimal.mark = ",")`**.

Considerando una población en España de **`r format(poblESP/1E+06, big.mark = ".", decimal.mark = ",")`** millones de personas según los datos publicados por el INE (Instituto Nacional de Estadística) correspondientes al inicio del año 2020, el porcentaje de contagio de la población es del **`r PorcentajePoblacion`** hasta la fecha.

## Incidencia semanal

### - Evolución de número de casos identificados por semanas:

```{r Incidencia Semanal}
CasosSemanales <- tapply(Datos$num_casos, week(Datos$fecha), sum)
dfCasosSemanales <- data.frame(Semana = 1:length(CasosSemanales), Casos =  
                                       CasosSemanales)
d <- ggplot(dfCasosSemanales, aes(Semana, Casos))
d + geom_col()
```

## Incidencia diaria

### - Curva epidémica de los casos notificados por días:

```{r Incidencia Diaria}
dfCasosDiarios <- data.frame(Fecha = Datos$fecha, Casos = Datos$num_casos)
d <- ggplot(dfCasosDiarios, aes(Fecha, Casos))
d + geom_col()
```

### - Gráfico de casos acumulados a origen por días:

```{r Casos acumulados a origen}
CasosDiariosAcumul <- cumsum(dfCasosDiarios$Casos)
dfCasosDiariosAcumul <- data.frame(Fecha = Datos$fecha, Casos = CasosDiariosAcumul)
d <- ggplot(dfCasosDiariosAcumul, aes(Fecha, Casos))
d + geom_col()
```

## Detalle del número de casos en los dos primeros meses de 2020

### - Evolución diaria del número de casos durante los dos primeros meses del año:

```{r Evolución Diaria Enero-Febrero}
PeriodoEF <- seq.Date(
  from = as.Date("2020-01-01"),
  to = as.Date("2020-02-29"),
  by = "day")
DatosEF <- subset(Datos, fecha %in% PeriodoEF)
CasosDiariosEF <- tapply(DatosEF$num_casos, yday(DatosEF$fecha), sum)
dfCasosDiariosEF <- data.frame(Fecha = 1:length(CasosDiariosEF), Casos =  CasosDiariosEF)
TotalCasosEF <- sum(DatosEF$num_casos)
d <- ggplot(dfCasosDiariosEF, aes(Fecha, Casos))
d + geom_col()
```

Los casos reportados totales a lo largo de esos dos meses son **`r format(TotalCasosEF, big.mark = ".", decimal.mark = ",")`**, si bien es claro que se produce una acusada inflexión en la pendiente de crecimiento a partir del día 50.

```{r Primeros 50+10 días}
Periodo1_50 <- seq.Date(
  from = as.Date("2020-01-01"),
  to = as.Date("2020-02-19"),
  by = "day")
Periodo51_60 <- seq.Date(
  from = as.Date("2020-02-20"),
  to = as.Date("2020-02-29"),
  by = "day")
Datos1_50 <- subset(Datos, fecha %in% Periodo1_50)
Datos51_60 <- subset(Datos, fecha %in% Periodo51_60)
TotalCasos1_50 <- sum(Datos1_50$num_casos)
TotalCasos51_60 <- sum(Datos51_60$num_casos)
```


Siendo así que el desglose de número agregado de casos identificados en dichos primeros 50 días y los siguientes 10 días queda de la siguiente manera:

* Periodo 1-50: `r TotalCasos1_50`
* Periodo 51-60: `r format(TotalCasos51_60, big.mark = ".", decimal.mark = ",")`

En 10 días se detectan **`r format(round(TotalCasos51_60/TotalCasos1_50, digits = 1), decimal.mark = ",")`** veces los casos que se habían producido en los 50 días anteriores.

## Subsiguiente evolución durante la primera quincena de marzo

En este apartado analizamos cómo continúa desarrollándose la propagación de la pandemia a principos del mes de marzo, estableciendo por su relevancia en lo ocurrido en España durante esos días dos periodos de tiempo diferenciados, del 1 al 8 y del 9 al 15.

```{r Primeros Quince Días Marzo}
Periodo1_8mar <- seq.Date(
  from = as.Date("2020-03-01"),
  to = as.Date("2020-03-08"),
  by = "day")
Periodo9_15mar <- seq.Date(
  from = as.Date("2020-03-09"),
  to = as.Date("2020-03-15"),
  by = "day")
Datos1_8mar <- subset(Datos, fecha %in% Periodo1_8mar)
Datos9_15mar <- subset(Datos, fecha %in% Periodo9_15mar)
CasosDiarios1_8mar <- tapply(Datos1_8mar$num_casos, yday(Datos1_8mar$fecha), sum)
CasosDiarios9_15mar <- tapply(Datos9_15mar$num_casos, yday(Datos9_15mar$fecha), sum)
TotalCasos1_8mar <- sum(Datos1_8mar$num_casos)
TotalCasos9_15mar <- sum(Datos9_15mar$num_casos)
```

En los primeros ocho días de marzo la progresión diaria de nuevos casos siguió disparándose, resultando un total de **`r format(TotalCasos1_8mar, big.mark = ".", decimal.mark = ",")`** casos a añadir al total anterior, siendo éstos **`r format(round(TotalCasos1_8mar/TotalCasosEF, digits = 1), decimal.mark = ",")`** veces los registrados a lo largo de todo enero y febrero.

Durante los siguientes siete días, del 9 al 15 de marzo, los casos a sumar fueron **`r format(TotalCasos9_15mar, big.mark = ".", decimal.mark = ",")`**, lo que supone **`r format(round(TotalCasos9_15mar/TotalCasos1_8mar, digits = 1), decimal.mark = ",")`** veces los notificados en los 8 primeros días del mes.

### - Gráfico del número de casos diarios desde el 1 de enero hasta el 15 de marzo de 2020: 

```{r Casos Diarios Hasta 15mar}
CasosDiariosHasta15mar <- c(CasosDiariosEF, CasosDiarios1_8mar, CasosDiarios9_15mar)
dfCasosDiariosHasta15mar <- data.frame(Fecha = 1:length(CasosDiariosHasta15mar), Casos = 
                                               CasosDiariosHasta15mar)
d <- ggplot(dfCasosDiariosHasta15mar, aes(Fecha, Casos))
d + geom_col()
```

## Incidencia acumulada por 100.000 habitantes en los 14 días previos a la declaración del estado de alarma del 14 de marzo

Pasemos ahora a calcular la incidencia acumulada por cada 100.000 habitantes en los 14 días previos a la declaración del estado de alarma que tuvo efecto

```{r Incidencia Acumulada Previa Estado Alarma}
PeriodoPrevioEstadoAlarma <- seq.Date(
  from = as.Date("2020-02-29"),
  to = as.Date("2020-03-13"),
  by = "day")
DatosPrevioEstadoAlarma <- subset(Datos, fecha %in% PeriodoPrevioEstadoAlarma)
IncidAcumPrevioEstadoAlarma <- sum(DatosPrevioEstadoAlarma$num_casos)/poblESP*1E+05
```

Tomando esos 14 días previos, es decir, entre el 29 de febrero y el 13 de marzo, la incidencia acumulada por cada 100.000 habitantes, con el mismo dato de población presentado más arriba fue de **`r round(IncidAcumPrevioEstadoAlarma)`** casos/100.000 hab.

Contrasta este valor de forma muy llamativa con los límites que se han estado manejando en la segunda ola de infecciones, donde se ha hablado de 200, 500 e incluso 1.000 casos/100.000 hab.

## Evolución de la incidencia acumulada a lo largo de todo el año

En el siguiente gráfico se representan las incidencias acumuladas por cada 100.000 habitantes correspondientes a periodos de 14 y 7 días:

```{r Evolución de la Incidencia Acumulada}
Fechas <- seq.Date(as.Date("2020-01-01"), by = "day", length.out = 
                           length(dfCasosDiarios$Fecha))
UltFecha <- Fechas[length(Fechas)]
stopifnot(UltFecha == max(Datos$fecha))  ## Prueba interna consistencia datos

## Inicialización de variables
InicioPeriodo14 <- as.Date("2020-01-01")
FinPeriodo14 <- InicioPeriodo14 + 13
IncidAcum14 <- data.frame(Fecha=as.Date(character()), IA14=integer()) 
IA14aux <- as.integer()
InicioPeriodo7 <- as.Date("2020-01-01")
FinPeriodo7 <- InicioPeriodo7 + 6
IncidAcum7 <- data.frame(Fecha=as.Date(character()), IA7=integer()) 
IA7aux <- as.integer()

## Incidencia acumulada 14 días
while (FinPeriodo14 <= UltFecha) {
        IA14aux <- 0
        Periodo14 <- seq.Date(
                from = InicioPeriodo14,
                to = FinPeriodo14,
                by = "day")
        DatosIA14 <- subset(Datos, fecha %in% Periodo14)
        IA14aux <- round(sum(DatosIA14$num_casos)/poblESP*1E+05, digits = 0)
        IncidAcum14 <- add_row(IncidAcum14, Fecha = FinPeriodo14, IA14 = IA14aux)
        InicioPeriodo14 <- InicioPeriodo14 + 1
        FinPeriodo14 <- FinPeriodo14 + 1
}

## Incidencia acumulada 7 días
while (FinPeriodo7 <= UltFecha) {
        IA7aux <- 0
        Periodo7 <- seq.Date(
                from = InicioPeriodo7,
                to = FinPeriodo7,
                by = "day")
        DatosIA7 <- subset(Datos, fecha %in% Periodo7)
        IA7aux <- round(sum(DatosIA7$num_casos)/poblESP*1E+05, digits = 0)
        IncidAcum7 <- add_row(IncidAcum7, Fecha = FinPeriodo7, IA7 = IA7aux)
        InicioPeriodo7 <- InicioPeriodo7 + 1
        FinPeriodo7 <- FinPeriodo7 + 1
}

## Gráficos de Incidencia acumulada por separado
## d <- ggplot(IncidAcum14, aes(Fecha, IA14)) + labs(y = "Incidencia Acumulada 14 días")
## d + geom_col()
## e <- ggplot(IncidAcum7, aes(Fecha, IA7)) + labs(y = "Incidencia Acumulada 7 días")
## e + geom_col()

## Gráficos de Incidencia Acumulada superpuestos
        ## Combinaión de ambos data frames en IncidAcum7_14
IncidAcum7_14 <- add_column(IncidAcum7, IA14=c(rep(0, 7), IncidAcum14$IA14))
                ## 7 primeros valores deberían ser NA, 0 para evitar aviso
g <- ggplot(IncidAcum7_14, aes(Fecha)) + labs(y = "Incidencia Acumulada 7/14 días")
g <- g + scale_color_manual(name="Inc.Acum./100.000", 
                           values = c("14 días" = "blue", "7 días" = "red"))
g <- g + geom_step(aes(y=IA14, color="14 días"))
g <- g + geom_step(aes(y=IA7, color="7 días"))
g
```

## Comparación de la evolución del número de casos entre Madrid y otras CCAA

En el siguiente gráfico se compara la evolución de la enfermedad entre comunidades muy diferentes, la Comunidad Autónoma de Madrid, Cantabria, Asturias y Galicia:

```{r Casos reportados en Madrid, Cantabria, Asturias y Galicia}
## ISO CCAA: Madrid = MD, Cantabria = CB, Asturias = AS, Galicia = GA
CasosDiariosMD <- filter(DatosCCAAs, ccaa_iso == "MD")
CasosDiariosMD <- subset (CasosDiariosMD, select = -ccaa_iso)
CasosDiariosCB <- filter(DatosCCAAs, ccaa_iso == "CB")
CasosDiariosCB <- subset (CasosDiariosCB, select = -ccaa_iso)
CasosDiariosAS <- filter(DatosCCAAs, ccaa_iso == "AS")
CasosDiariosAS <- subset (CasosDiariosAS, select = -ccaa_iso)
CasosDiariosGA <- filter(DatosCCAAs, ccaa_iso == "GA")
CasosDiariosGA <- subset (CasosDiariosGA, select = -ccaa_iso)
CasosDiariosCCAA <- add_column(CasosDiariosMD, CasosDiariosCB$num_casos, 
                               CasosDiariosAS$num_casos, CasosDiariosGA$num_casos)
colnames(CasosDiariosCCAA) <- c("Fecha", "CasosMD", "CasosCB", "CasosAS", "CasosGA")
g <- ggplot(CasosDiariosCCAA, aes(Fecha)) + labs(y = "Casos reportados")
g <- g + scale_color_manual(name="Nº de casos", 
                           values = c("Madrid"="blue", "Cantabria"="red", 
                                      "Asturias"="green", "Galicia"="orange"))
g <- g + geom_step(aes(y=CasosMD, color="Madrid"))
g <- g + geom_step(aes(y=CasosCB, color="Cantabria"))
g <- g + geom_step(aes(y=CasosAS, color="Asturias"))
g <- g + geom_step(aes(y=CasosGA, color="Galicia"))
g
```

Como es lógico, los datos no son comparables en términos absolutos por la gran diferencia de población entre estas comunidades autónomas, por no entrar en la forma de vida en unas y otras, aunque sí que haya similitudes entre las de la cornisa cantábrica, y en cómo esto impacta en la dispersión de la enfermedad. 

Para solventar este problema representamos ahora número de casos por cada 100.000 habitantes, con los datos de población en cada comunidad disponibles en el momento en el INE  (<https://www.ine.es/dynInfo/Infografia/Territoriales/capitulo.html#!tabla>):

```{r Casos en Cantabria y Madrid por cada 100.000 habitantes}
poblMD <- 6.778E+06
poblCB <- 0.583E+06
poblAS <- 1.019E+06
poblGA <- 2.700E+06
IncidenciaCCAA <- data.frame(CasosDiariosCCAA$Fecha, 
                             CasosDiariosMD$num_casos/poblMD*1E+05, 
                             CasosDiariosCB$num_casos/poblCB*1E+05, 
                             CasosDiariosAS$num_casos/poblAS*1E+05, 
                             CasosDiariosGA$num_casos/poblGA*1E+05)
colnames(IncidenciaCCAA) <- c("Fecha", "IncidMD", "IncidCB", "IncidAS", "IncidGA")
g <- ggplot(IncidenciaCCAA, aes(Fecha)) + 
        labs(y = "Incidencia (Casos / 100.000 hab.)")
g <- g + scale_color_manual(name="Incidencia/100.000", 
                           values = c("Madrid"="blue", "Cantabria"="red", 
                                      "Asturias"="green", "Galicia"="orange"))
g <- g + geom_step(aes(y=IncidMD, color="Madrid"))
g <- g + geom_step(aes(y=IncidCB, color="Cantabria"))
g <- g + geom_step(aes(y=IncidAS, color="Asturias"))
g <- g + geom_step(aes(y=IncidGA, color="Galicia"))
## g <- g + theme(legend.justification = "center", legend.position = "right")
g
```

Por completar la información comparativa entre estas comunidades se adjunta también la incidencia acumulada en 14 días para estas áreas geográficas, junto con la correspondiente al conjunto del territorio nacional:

```{r Incidencias acumuladas 14 días CCAA + España}
InicioPeriodo14 <- as.Date("2020-01-01")
FinPeriodo14 <- InicioPeriodo14 + 13
IA14_CCAA <- data.frame(Fecha=as.Date(character()), IA14_MD=integer(), 
                        IA14_CB=integer(), IA14_AS=integer(), IA14_GA=integer()) 
IA14aux <- as.integer()
while (FinPeriodo14 <= UltFecha) {
        IA14auxMD <- 0
        IA14auxCB <- 0
        IA14auxAS <- 0
        IA14auxGA <- 0
        Periodo14 <- seq.Date(
                from = InicioPeriodo14,
                to = FinPeriodo14,
                by = "day")
        DatosIA14_CCAA <- subset(IncidenciaCCAA, Fecha %in% Periodo14)
        IA14auxMD <- round(sum(DatosIA14_CCAA$IncidMD), digits = 0)
        IA14auxCB <- round(sum(DatosIA14_CCAA$IncidCB), digits = 0)
        IA14auxAS <- round(sum(DatosIA14_CCAA$IncidAS), digits = 0)
        IA14auxGA <- round(sum(DatosIA14_CCAA$IncidGA), digits = 0)
        IA14_CCAA <- add_row(IA14_CCAA, Fecha = FinPeriodo14, IA14_MD = IA14auxMD, 
                             IA14_CB = IA14auxCB, IA14_AS = IA14auxAS, 
                             IA14_GA = IA14auxGA)
        InicioPeriodo14 <- InicioPeriodo14 + 1
        FinPeriodo14 <- FinPeriodo14 + 1
}
## Añadiendo columna con valores a nivel nacional
IA14_CCAANac <- add_column(IA14_CCAA, IA14_Nacional=IncidAcum14$IA14)
## Gráfico
g <- ggplot(IA14_CCAANac, aes(Fecha))
g <- g + labs(y = "Incidencia acumulada 14 días / 100.000 hab.")
g <- g + scale_color_manual(name = "IA14d/100.000", 
                            values = c("Madrid"="blue", "Cantabria"="red", 
                                       "Asturias"="green", "Galicia"="orange", 
                                       "Nacional" = "black"))
g <- g + geom_step(aes(y=IA14_MD, color="Madrid"))
g <- g + geom_step(aes(y=IA14_CB, color="Cantabria"))
g <- g + geom_step(aes(y=IA14_AS, color="Asturias"))
g <- g + geom_step(aes(y=IA14_GA, color="Galicia"))
g <- g + geom_step(aes(y=IA14_Nacional, color="Nacional"))
## g <- g + theme(legend.justification = "center", legend.position = "right")
g
```

## Exceso de mortalidad

Como último paso del análisis obtendremos cifras del exceso de mortalidad registrado en este año, presumiblemente achacable a la incidencia de la pandemia de la COVID-19. Los datos se han obtenido del enlace del **Instituto de Salud Carlos III**: <https://momo.isciii.es/public/momo/data>.

```{r Lectura de datos MoMo}
DatosCompletosMoMo <- read.csv(file.path("data", "data.csv"))
## Descartamos información de detalle de CCAA, sexos y grupos de edad
DatosMoMo <- DatosCompletosMoMo[DatosCompletosMoMo$ambito == "nacional" & 
                                DatosCompletosMoMo$cod_sexo == "all" & 
                                DatosCompletosMoMo$cod_gedad == "all" & 
                                DatosCompletosMoMo$fecha_defuncion > "2019-12-31", 
                                c(9:10, 13:15)]
colnames(DatosMoMo) <- c("Fecha", "DefObs", "DefEsp", "DefEsp_q01", "DefEsp_q99")
DatosMoMo <- as.data.table(DatosMoMo)
## Adecuación formato fechas para su correcta lectura
DatosMoMo$Fecha <- as.Date(DatosMoMo$Fecha, format = "%Y-%m-%d")
```

La fecha y hora de descarga de los datos de mortalidad utilizados para la elaboración de los siguientes gráficos y tablas fue (aaaa-mm-dd hh:mm:ss): **`r file.mtime(file.path("data", "data.csv"))`**
 
Representemos en primer lugar la evolución del número de defunciones en comparación con las esperadas y su rango para los percentiles 1 y 99:

```{r Gráfico mortalidad 2020}
g <- ggplot(DatosMoMo, aes(Fecha))
g <- g + labs(y = "Defunciones")
g <- g + scale_color_manual(name = "Defunciones", 
                            values = c("Observadas"="black", "Esperadas"="blue"))
g <- g + geom_ribbon(aes(ymin=DefEsp_q01, ymax=DefEsp_q99), alpha=0.25, fill="blue")
g <- g + geom_line(aes(y=DefObs, color="Observadas"))
g <- g + geom_line(aes(y=DefEsp, color="Esperadas"))
## g <- g + theme(legend.justification = "center", legend.position = "right")
g
```

Como se puede ver, existe un periodo de mortalidad totalmente disparada a lo largo de los meses de marzo a mayo, con una punta con valores cercanos al triple de lo esperado, mientras que luego se aprecia otro periodo de desviación al alza, no tan acusado pero más prolongado en el tiempo y con una tendencia creciente, que cubríría desde agosto hasta bien avanzado noviembre.

Técnicamente se define "periodo de exceso de mortalidad" cuando se cumplen las siguientes condiciones:

* Se observa al menos dos días consecutivos con defunciones observadas por encima del percentil 99 de las estimadas.
* La fecha de inicio del periodo es el primer día con las defunciones observadas por encima de las estimadas.
* La fecha de fin del periodo es el último día con las defunciones observadas por encima de las estimadas.
* Si entre la fecha de fin de un periodo y la fecha de inicio del siguiente hay dos días, se unifican ambos periodos, tomando la fecha de inicio del primer periodo y fecha de fin del último.

Con estas premisas podemos aislar los periodos en los que se han producido dichas circunstancias y calcular el exceso de defunciones durante esos lapsos de tiempo concretos. Ahora bien, antes de pasar a realizar dichos cálculos, realicemos uno más básico, comparando directamente las cifras de defunciones esperadas acumuladas a lo largo del año con las que realmente se han registrado:

```{r Defunciones acumuladas - esperadas y observadas}
DatosMoMo[,AcumObs := cumsum(DefObs)]
DatosMoMo[,AcumEsp := cumsum(DefEsp)]
g <- ggplot(DatosMoMo, aes(Fecha))
g <- g + labs(y = "Defunciones Acumuladas a Origen de Año")
g <- g + scale_color_manual(name = "Defunciones acumuladas", 
                            values = c("Observadas"="black", "Esperadas"="blue"))
g <- g + geom_line(aes(y=AcumObs, color="Observadas"))
g <- g + geom_line(aes(y=AcumEsp, color="Esperadas"))
## g <- g + theme(legend.justification = "center", legend.position = "right")
g
```

Como podíamnos esperar, esta gráfica no aporta gran valor a la hora de la interpretación de la información, más allá del hecho de que las defunciones observadas se distancian de las esperadas de forma muy visible a lo largo de los meses de marzo a mayo, y que dicho distanciamento se vuelve a incrementar, ya a menor ritmo, a partir del mes de agosto, aunque se aprecia que vuelve a repuntar ligeramente en noviembre.

```{r Cifras relevantes defunciones}
## Acumulados totales desde inicio de 2020
TotalDefAcumObs <- last(DatosMoMo$AcumObs)
TotalDefAcumEsp <- round(last(DatosMoMo$AcumEsp))
TotalExcesoDef <- TotalDefAcumObs - TotalDefAcumEsp
PorcentajeExcesoDef <- round(TotalExcesoDef/TotalDefAcumEsp*100, 1)
## Acumulados desde inicio de 2020 hasta 21 de junio de 2020
DefAcumObs21jun <- DatosMoMo$AcumObs[DatosMoMo$Fecha == "2020-06-21"]
DefAcumEsp21jun <- round(DatosMoMo$AcumEsp[DatosMoMo$Fecha == "2020-06-21"])
ExcesoDef21jun <- DefAcumObs21jun - DefAcumEsp21jun
PorcentExcesoDef21jun <- round(ExcesoDef21jun/DefAcumEsp21jun*100, 1)
```

Más interesentante resulta la comparación directa de las cifras acumuladas hasta la fecha. En este caso tenemos, con los datos disponibles, una total de **`r format(TotalDefAcumObs, big.mark = ".", decimal.mark = ",")`** defunciones observadas y **`r format(TotalDefAcumEsp, big.mark = ".", decimal.mark = ",")`** defunciones esperadas, resultando un exceso de **`r format(TotalExcesoDef, big.mark = ".", decimal.mark = ",")`** defunciones. Expresando dicho exceso en términos porcentuales, nos encontramos con un **`r format(PorcentajeExcesoDef, decimal.mark = ",")` %** más fallecimientos de los esperados.

Por afán de completar la visión de la evolución de estas variables, presentamos a continuación esos mismos valores en la fecha en la que se levantó el estado de alarma, 21 de junio de 2020, buscando una fecha en lo que podríamos denominar **"final de la primera ola"**, que no ***"la derrota de la pandemia"*** (sic):

* Defunciones acumuladas observadas: **`r format(DefAcumObs21jun, big.mark = ".", decimal.mark = ",")`** personas
* Defunciones acumuladas esperadas: **`r format(DefAcumEsp21jun, big.mark = ".", decimal.mark = ",")`** personas
* Esceso de defunciones: **`r format(ExcesoDef21jun, big.mark = ".", decimal.mark = ",")`** personas
* En tanto por ciento: **`r format(PorcentExcesoDef21jun, decimal.mark = ",")` %**  

Retomando la senda de la ortodoxia y aplicando ahora sí los criterios técnicos "oficiales" que presentábamos más arriba que definen los periodos de exceso de mortalidad, las fechas que delimitan el principio y final de los periodos de exceso padecidos a lo largo de 2020 son (fechas en formato aaaa-mm-dd):

```{r Fechas delimitación periodos exceso}
## Columnas auxiliares variables buleanas
DatosMoMo[, MQEsp := DefObs>DefEsp]
DatosMoMo[, MQEsp99_2dias := {DefObs>DefEsp_q99 & lag(DefObs)>lag(DefEsp_q99)}]
## Determinar inicio y fin de periodos de exceso
PeriodosExceso <- data.table("Inicio"=as.Date(character()), "Fin"=as.Date(character()))
i <- as.integer(1)
while (i < nrow(DatosMoMo)) { ## Recorrer tabla
        if (DatosMoMo$MQEsp99_2dias[i] == TRUE) { ## Encontrar dos días > quant99(Esp)
                j <- as.integer(1)
                while (DatosMoMo$MQEsp[i-j] == TRUE && DatosMoMo$MQEsp[i-j-1] == TRUE)
                {j <- j + 1}
                PeriodosExcesoInicioN <- as.Date(DatosMoMo$Fecha[i-j])
                for (k in 0:(nrow(DatosMoMo)-i)) {
                        if (i + k == nrow(DatosMoMo)) {
                                PeriodosExcesoFinN <- as.Date(DatosMoMo$Fecha[i+k])
                                PeriodosExceso <- add_row(PeriodosExceso, 
                                                          Inicio = PeriodosExcesoInicioN,
                                                          Fin = PeriodosExcesoFinN)
                                break
                        }
                        if (DatosMoMo$MQEsp[i+k] == TRUE && 
                                DatosMoMo$MQEsp[i+k+1] == FALSE) {
                                PeriodosExcesoFinN <- as.Date(DatosMoMo$Fecha[i+k])
                                PeriodosExceso <- add_row(PeriodosExceso, 
                                                          Inicio = PeriodosExcesoInicioN,
                                                          Fin = PeriodosExcesoFinN)
                                i <- i + k
                                break
                        }
                }
        }
        i <- i + 1
}
## Unir periodos de exceso próximos
PeriodosExcesoUnido <- data.table("Inicio"=as.Date(character()), 
                                  "Fin"=as.Date(character()))
n <- as.integer(1)
while (n <= nrow(PeriodosExceso)) {
        PeriodosExcesoUnidoInicioN <- PeriodosExceso$Inicio[n]
        while (((PeriodosExceso$Inicio[n+1] - PeriodosExceso$Fin[n]) <= 2) &
               n < nrow(PeriodosExceso)) {n <- n + 1}
        PeriodosExcesoUnidoFinN <- PeriodosExceso$Fin[n]
        PeriodosExcesoUnido <- add_row(PeriodosExcesoUnido, 
                                       Inicio = PeriodosExcesoUnidoInicioN, 
                                       Fin = PeriodosExcesoUnidoFinN)
        n <- n + 1
}
```

* Antes de unificar periodos de exceso próximos:

`r kable(PeriodosExceso, align = "c")`

* Después de unificar los periodos de exceso cercanos (<= 2 días):

`r kable(PeriodosExcesoUnido, align = "c")`

```{r Determinación de los excesos de defunciones en los periodos}
## Excesos de defunciones durante los periodos de exceso
PeriodoExcesoN <- as.Date(character())
ExcesoDefunciones <- data.table("Exceso"=integer())
DefuncionesEsperadas <- data.table("Esperadas"=integer())
for (i in 1:nrow(PeriodosExcesoUnido)) {
        PeriodoExcesoN <- seq.Date(
                from = as.Date(PeriodosExcesoUnido$Inicio[i]), 
                to = as.Date(PeriodosExcesoUnido$Fin[i]), 
                by = "day")
        DatosMoMoPeriodoN <- subset(DatosMoMo, Fecha %in% PeriodoExcesoN)
        ExcesoDefunciones <- add_row(ExcesoDefunciones, "Exceso" = 
                                     (sum(DatosMoMoPeriodoN$DefObs)
                                     -round(sum(DatosMoMoPeriodoN$DefEsp))))
        DefuncionesEsperadas <- add_row(DefuncionesEsperadas, "Esperadas"=
                                     round(sum(DatosMoMoPeriodoN$DefEsp)))
}
PeriodosExcesoUnido <- add_column(PeriodosExcesoUnido, "Exceso de defunciones" = 
                                          ExcesoDefunciones$Exceso)
TotalExcesoDefunciones <- sum(PeriodosExcesoUnido$"Exceso de defunciones")
```

Los excesos de defunciones en estos `r nrow(PeriodosExcesoUnido)` periodos son:

`r kable(PeriodosExcesoUnido, align = "c", format.args = list(big.mark=".", decimal.mark=","))`

Siendo el total agregado de exceso de defunciones de **`r format(TotalExcesoDefunciones, big.mark = ".", decimal.mark = ",")`** personas.

Expresándolo en términos porcentuales, el exceso de defunciones es un **`r format(round((TotalExcesoDefunciones / TotalDefAcumEsp*100), 1), decimal.mark = ",")` %** superior al total de las esperadas hasta la fecha. Como es lógico, este valor porcentual se irá reduciendo a medida que transcurra el tiempo desde el final del último episodio de exceso de defunciones.

Para eliminar esta dependencia temporal, veamos estos excesos en términos porcentuales con respecto a las esperadas, pero  circunscritos exclusivamente al propio periodo de exceso de defunciones y dejando fuera el resto de la serie temporal:

```{r Porcentaje Exceso defunciones en periodos de exceso}
PeriodosExcesoUnido <- add_column(PeriodosExcesoUnido, "Porcentaje de exceso" = 
                                  round((PeriodosExcesoUnido$"Exceso de defunciones" /
                                  DefuncionesEsperadas$Esperadas * 100), 1))
```

`r kable(PeriodosExcesoUnido, align = "c", format.args = list(big.mark=".", decimal.mark=","))`

Aunque en el exceso de defunciones haya casos de fallecimiento no directamente imputables a la COVID-19, hay que asignar dichas muertes a la crisis del COVID-19. Si determinadas patologías no son debidamente atendidas en tiempo y forma por la sobrecarga del sistema sanitario provocado por la pandemia, los fallecimientos asociados a las mismas son por tanto atribuibles a la COVID-19 aunque el virus no haya sido la causa directa del fallecimiento correspondiente.

El índice de mortalidad de la COVID-19 en España en 2020, medido como exceso de mortalidad atribuible directa o indrectamente a la COVID por cada mil habitantes, es de **`r format(TotalExcesoDefunciones/poblESP*1e3, digits = 3, big.mark = ".", decimal.mark = ",")`**.

Para tener algo con lo que comparar, el índice de mortalidad observado por todas las causas, en lo que va de año de 2020, es de **`r format(TotalDefAcumObs/poblESP*1e3, digits = 3, big.mark = ".", decimal.mark = ",")`**, mientras que el esperado a estas alturas de año sería de **`r format(TotalDefAcumEsp/poblESP*1e3, digits = 3, big.mark = ".", decimal.mark = ",")`**, en ambos casos también por cada mil habitantes.

Antes de seguir avanzando no podemos dejar de llamar la atención sobre el hecho de que en la determinación de las cifras de exceso de defunciones se ha utilizado como nivel de referencia el número de defunciones esperadas. Es perfectamente argumentable que durante el periodo de estado de alarma este nivel de comparación debería ser inferior al estadisticamente obtenido con datos de años previos ya que el propio estado de alarma tuvo por necesidad incidencia en el número de fallecimientos por accidente laboral y por accidente de tráfico, sin duda disminuyéndolos. Consecuentmente debería rebajarse el patrón de referencia de defunciones esperadas durante el estado de confinamiento y el exceso de defunciones por causa de la COVID-19 sería superior al mostrado más arriba. Aunque es posible realizar estimaciones de estas desviaciones con datos disponibles públicamente, dejamos esa posibilidad de perfeccionamiento del estudio para mejor oportunidad.

## Análisis por grupos de edad y sexo de las defunciones ocurridas durante la primera ola de la pandemia

En este apartado haremos una somera disección de los fallecimientos producidos durante la primera ola de la pandemia por grupos de edad y por sexo. Tomaremos como periodo de referencia para el análisis de datos el correspondiente al primer periodo de exceso de defunciones tal y como se definió y determinó más arriba.

En resumen, los datos que se presentan ahora corresponden al periodo entre el **`r format(PeriodosExcesoUnido[1,1], "%d de %B de %Y")`** y el **`r format(PeriodosExcesoUnido[1,2], "%d de %B de %Y")`**.

En primera instancia nos limitaremos a analizar los datos para el agregado nacional, sin entrar en el detalle de lo acontecido en cada comunidad autónoma.

```{r Análisis por grupos de edad y sexo defunciones en la primera ola}
PeriodoOla1 <- as.Date(character())
PeriodoOla1 <- seq.Date(from = as.Date(PeriodosExcesoUnido$Inicio[1]), 
                           to = as.Date(PeriodosExcesoUnido$Fin[1]), 
                           by = "day")
DatosMoMoOla1 <- subset(DatosCompletosMoMo, as.Date(fecha_defuncion) %in% 
                        PeriodoOla1 & DatosCompletosMoMo$ambito == "nacional", 
                        select = c(6, 8:10))
colnames(DatosMoMoOla1) <- c("sexo", "edad", "fecha", "defunciones")
DatosMoMoOla1 <- as.data.table(DatosMoMoOla1)
DatosMoMoOla1$fecha <- as.Date(DatosMoMoOla1$fecha, format = "%Y-%m-%d")
DatosMoMoOla1$sexo <- factor(DatosMoMoOla1$sexo, levels = c("hombres", "mujeres", 
                                                            "todos"))
DatosMoMoOla1$edad <- factor(DatosMoMoOla1$edad, levels = c("edad < 65", 
                                                            "edad 65-74", 
                                                            "edad > 75", 
                                                            "todos"))
TablaOla1 <- xtabs(defunciones ~ sexo + edad, data = DatosMoMoOla1)
```

`r kable(TablaOla1, align = "r", format.args = list(big.mark=".", decimal.mark=","))`

Nótese que los desgloses por sexo siempre suman una cantidad inferior al total agregado correspondiente. Esto no es un error de programación sino una deficiencia, característica intrínseca por decirlo de una forma eufemística, de los datos de partida, en los que para una fecha dada las sumas por sexos no llegan al "todos" correspondiente, ni en el agregado total ni en los subtotales por franjas de edad.

Ante la disyuntavia de cómo continuar después de detectada esta discordancia, en vez de quedarnos con los números que representan las agregaciones "todos" (fila inferior y columna derecha), daremos por buenos los datos de detalle y calcularemos los nuevos agregados parciales y total.

```{r Simplificación de tabla eliminando grupos "todos" Ola1}
DatosMoMoOla1 <- DatosMoMoOla1[sexo != "todos",]
DatosMoMoOla1 <- DatosMoMoOla1[edad != "todos",]
DatosMoMoOla1$sexo <- factor(DatosMoMoOla1$sexo, levels = c("hombres", "mujeres"))
DatosMoMoOla1$edad <- factor(DatosMoMoOla1$edad, levels = c("edad < 65", 
                                                            "edad 65-74", 
                                                            "edad > 75"))
TablaOla1 <- addmargins(xtabs(defunciones ~ sexo + edad, data = DatosMoMoOla1))
TablaOla1Porc <- addmargins(prop.table(xtabs(defunciones ~ sexo + edad, data = 
                                               DatosMoMoOla1))*100)
```

La nueva tabla de distribución por sexos y edad queda entonces de la siguiente manera:

Expresándolo en número de defunciones:

`r kable(TablaOla1, align = "r", format.args = list(big.mark=".", decimal.mark=","))`

Representándolo como porcentajes:

`r kable(TablaOla1Porc, align = "r", format.args = list(digits = 3, big.mark=".", decimal.mark=","))`

Sobre esta tabla hay que remarcar el hecho de que estamos obteniendo el total de fallecimientos, con independencia de la causa, no sólo por la COVID-19, con lo cual por sí sola no puede arrojar mucha luz ya que no podemos separar los casos "Covid" de los "no-Covid". Lo que haremos para solventar esta carencia es comparar el reparto porcentual durante la ola con un periodo de referencia. En este caso no nos complicaremos con medias de largos periodos y lo compararemos con la distribución correspondiente al año 2019.

```{r Grupos de edad y sexo en las defunciones de 2019}
Periodo2019 <- as.Date(character())
Periodo2019 <- seq.Date(from = as.Date("2019-01-01"), 
                           to = as.Date("2019-12-31"), 
                           by = "day")
DatosMoMo2019 <- subset(DatosCompletosMoMo, as.Date(fecha_defuncion) %in% 
                        Periodo2019 & DatosCompletosMoMo$ambito == "nacional", 
                        select = c(6, 8:10))
colnames(DatosMoMo2019) <- c("sexo", "edad", "fecha", "defunciones")
DatosMoMo2019 <- as.data.table(DatosMoMo2019)
DatosMoMo2019$fecha <- as.Date(DatosMoMo2019$fecha, format = "%Y-%m-%d")
DatosMoMo2019$sexo <- factor(DatosMoMo2019$sexo, levels = c("hombres", "mujeres", 
                                                            "todos"))
DatosMoMo2019$edad <- factor(DatosMoMo2019$edad, levels = c("edad < 65", 
                                                            "edad 65-74", 
                                                            "edad > 75", 
                                                            "todos"))
Tabla2019 <- xtabs(defunciones ~ sexo + edad, data = DatosMoMo2019)
```

`r kable(Tabla2019, align = "r", format.args = list(big.mark=".", decimal.mark=","))`

Como ya apuntábamos antes, el problema de falta de coherencia entre los grupos "todos" y sus desgloses es inherente a los propios datos y volveremos a depurarlos de la misma manera en esta ocasión, conservando los desgloses y calcuando nuevos subtotales y total agregado:

```{r Simplificación de tabla eliminando grupos "todos" 2019}
DatosMoMo2019 <- DatosMoMo2019[sexo != "todos",]
DatosMoMo2019 <- DatosMoMo2019[edad != "todos",]
DatosMoMo2019$sexo <- factor(DatosMoMo2019$sexo, levels = c("hombres", "mujeres"))
DatosMoMo2019$edad <- factor(DatosMoMo2019$edad, levels = c("edad < 65", 
                                                            "edad 65-74", 
                                                            "edad > 75"))
Tabla2019 <- addmargins(xtabs(defunciones ~ sexo + edad, data = DatosMoMo2019))
Tabla2019Porc <- addmargins(prop.table(xtabs(defunciones ~ sexo + edad, data = 
                                               DatosMoMo2019))*100)
```

En número de fallecimientos:

`r kable(Tabla2019, align = "r", format.args = list(big.mark=".", decimal.mark=","))`

Como porcentajes:

`r kable(Tabla2019Porc, align = "r", format.args = list(digits = 3, big.mark=".", decimal.mark=","))`

Coloquemos las tablas de porcentajes juntas una con la otra para que sea fácil compararlas:

- Primera ola de la pandemia:

`r kable(TablaOla1Porc, align = "r", format.args = list(digits = 3, big.mark=".", decimal.mark=","))`

- Año 2019:

`r kable(Tabla2019Porc, align = "r", format.args = list(digits = 3, big.mark=".", decimal.mark=","))`

Como se puede ver, con estos datos no es posible afirmar que la COVID-19 en términos de mortalidad haya afectado significativamente más a la población másculina que a la femenina y sólo se puede apreciar un desplazamiento de los fallecimientos hacia las franjas de edad mayores, algo que por otro lado es esperable puesto que la enfermedad afecta más severamente a las personas con patologías previas y éstas se encuentran por lógica entre los grupos de edad más avanzada.

....................

## Referencias

(1) R Core Team (2020). R: A language and environment for statistical computing.
    R Foundation for Statistical Computing, Vienna, Austria. URL: 
    https://www.R-project.org/

(2) Garrett Grolemund, Hadley Wickham (2011). Dates and Times Made Easy with 
    lubridate. Journal of Statistical Software, 40(3), 1-25. URL: 
    http://www.jstatsoft.org/v40/i03/
    
(3) Yihui Xie (2020). knitr: A General-Purpose Package for Dynamic Report 
    Generation in R. R package version 1.30.

(4) Wickham et al., (2019). Welcome to the tidyverse. Journal of Open
    Source Software, 4(43), 1686, https://doi.org/10.21105/joss.01686
    
(5) Matt Dowle and Arun Srinivasan (2020). data.table: Extension of `data.frame`. 
    R package version 1.13.2. https://CRAN.R-project.org/package=data.table
